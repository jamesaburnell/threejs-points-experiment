<!DOCTYPE html>
<html lang="en">
	<head>
		<title>particles</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				color: #ffffff;
				background-color: #000000;
				margin: 0px;
				overflow: hidden;
			}
			#info {
				position: absolute;
				top: 0px;
				width: 100%;
				padding: 5px;
				font-family: Monospace;
				font-size: 13px;
				text-align: center;
				font-weight: bold;
			}
			a {
				color: #fff;
			}
		</style>
	</head>

	<body>
		<div id="container"></div>

		<script src="three.js"></script>
		<script src="perlin.js"></script>
		<script src="js/Detector.js"></script>
		<script src="js/libs/stats.min.js"></script>
		<script src="js/libs/dat.gui.min.js"></script>

		<script type="x-shader/x-vertex" id="vertexshader">

			attribute float size;
			attribute vec3 customColor;
			
			uniform float screenWidth;
			uniform float u_time;
			uniform float u_frequency;
			uniform float u_speed;
			uniform float u_displacement;
			uniform float u_scale;
			uniform float u_particleSize;
			uniform float u_bounce;
			uniform float noise;

			varying vec3 vColor;
			varying float vTime;

			varying float vNoise;

			const float PI = 3.1415926535897932384626433832795;
			const float PI_2 = 1.57079632679489661923;
			const float PI_4 = 0.785398163397448309616;

			float PI180 = float(PI / 180.0);
			float sind(float a){return sin(a * PI180);}
			float cosd(float a){return cos(a * PI180);}
			

			vec3 bounce(vec3 p, float t) {
				p.x = p.x + sin(t * u_bounce);
				return p;
			}


			void main() {

				vColor = customColor;

				float time = u_time / u_speed;
				vTime = time;

				vec3 pos = position;
				pos.x = pos.x + sin(pos.x + time);
				pos.y = pos.y + sin((( pos.y + (time / float(4)) ) * float(u_speed)) * float(u_frequency) * PI );

				pos = bounce(pos, time);

				vec4 posFinal = vec4(pos * vec3(u_displacement) * noise, 1.0);
				vec4 mvPosition = modelViewMatrix * posFinal;

				gl_PointSize = size * u_particleSize * (300.0 / -mvPosition.z);
				gl_Position = projectionMatrix * mvPosition;

			}


		</script>

		<script type="x-shader/x-fragment" id="fragmentshader">

			uniform vec3 color;
			uniform float noise;
			uniform sampler2D texture;

			varying vec3 vColor;
			varying float vTime;

			void main() {

				gl_FragColor = vec4( color * vColor * abs(tan(vTime - vColor)), 1.0 );
				gl_FragColor = gl_FragColor * texture2D( texture, gl_PointCoord );

				if ( gl_FragColor.a < ALPHATEST ) discard;

			}

		</script>


		<script>

			if ( ! Detector.webgl ) Detector.addGetWebGLMessage()

			let renderer, scene, camera, stats

			let particles, uniforms, clock, materials = [], boxes = [], materialTEST

			let PARTICLE_SIZE = 10

			let boxGroup, numRows = 6, numColumns = 6, numLayers = 6, boxMargin = 40

			let deltaOffset = 1



			// let raycaster, intersects;
			let mouse, INTERSECTED;
			
			let effectController = {
				x: 0.4,
				y: 0.8,
				z: 1.61
			}

			let particlesController = {
				frequency: 0.2,
				speed: 2,
				displacement: 1.41,
				scale: 1.5,
				size: 0.7,
				bounce: 2
			}

			init()
			animate()
			initGui()



			function init() {

				var container = document.getElementById( 'container' );

				scene = new THREE.Scene();

				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 10000 );
				camera.position.z = 500
				camera.position.y = 20
				camera.position.x = 60

				scene.background = new THREE.Color( 0x000000 );

				// points
				var geometry1 = new THREE.BoxGeometry( 10, 10, 10, 32, 32, 32 ); // new THREE.SphereGeometry(80, 256, 256) // new THREE.PlaneGeometry(200, 200, 128, 128) //
				var vertices = geometry1.vertices;

				var positions = new Float32Array( vertices.length * 3 );
				var colors = new Float32Array( vertices.length * 3 );
				var sizes = new Float32Array( vertices.length );

				var vertex;
				var color = new THREE.Color();

				var directionalLight = new THREE.DirectionalLight( 0xffffff, 1 );
				scene.add( directionalLight );

				clock = new THREE.Clock()
				clock.start()

				for ( var i = 0, l = vertices.length; i < l; i ++ ) {

					vertex = vertices[ i ];
					vertex.toArray( positions, i * 3 );

					color.setHSL( 0.01 + 0.1 * ( i / l ), 1.0, 0.5 );
					color.toArray( colors, i * 3 );

					sizes[ i ] = PARTICLE_SIZE * 0.5;

				}

				var geometry = new THREE.BufferGeometry();
				geometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
				geometry.addAttribute( 'customColor', new THREE.BufferAttribute( colors, 3 ) );
				geometry.addAttribute( 'size', new THREE.BufferAttribute( sizes, 1 ) );

				//

				boxGroup = new THREE.Group()

				let boxCount = 0, texture1 = new THREE.TextureLoader().load( "textures/sprites/disc.png" )

				
				
				for(let l = 0; l < numLayers; l++) {
					for(let i = 0; i < numRows; i++) {
						for(let h = 0; h < numColumns; h++) {

							materials[boxCount] = new THREE.ShaderMaterial({
								uniforms: {
									color:  		{ value: new THREE.Color( 0x551A8B ) },
									texture: 		{ value: texture1 },
									noise:   		{ value: 1.0 },
									u_time:  		{ value: (clock.getDelta() / deltaOffset) * boxCount},
									screenWidth: 	{ value: window.innerWidth },
									u_frequency: 	{ value: particlesController.frequency },
									u_speed: 		{ value: particlesController.speed },
									u_displacement: { value: particlesController.displacement},
									u_scale: 		{ value: particlesController.scale },
									u_particleSize: { value: particlesController.size },
									u_bounce: 		{ value: particlesController.bounce }
								},
								vertexShader: document.getElementById( 'vertexshader' ).textContent,
								fragmentShader: document.getElementById( 'fragmentshader' ).textContent,
								alphaTest: 0.9
							})

							particles = new THREE.Points( geometry, materials[boxCount] )
							particles.position.y = i * boxMargin
							particles.position.x = h * boxMargin
							particles.position.z = l * boxMargin

							boxes.push(particles)
							boxGroup.add(particles)
							boxCount++

						}
					}
				}

				boxGroup.rotation.x = effectController.x
				boxGroup.rotation.y = effectController.y
				boxGroup.rotation.z = effectController.z

				scene.add( boxGroup );
				
				//

				renderer = new THREE.WebGLRenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				container.appendChild( renderer.domElement );

				//

				raycaster = new THREE.Raycaster();
				mouse = new THREE.Vector2();

				//

				stats = new Stats();
				container.appendChild( stats.dom );

				//

				window.addEventListener( 'resize', onWindowResize, false );
				document.addEventListener( 'mousemove', onDocumentMouseMove, false );

			}

			function cameraValuesChanger() {
				boxGroup.rotation.x = effectController.x;
				boxGroup.rotation.y = effectController.y;
				boxGroup.rotation.z = effectController.z;
			}

			function particlesValuesChanger() {
				materials.forEach(e => {
					e.uniforms.u_frequency.value = particlesController.frequency
					e.uniforms.u_speed.value = particlesController.speed
					e.uniforms.u_displacement.value = particlesController.displacement
					e.uniforms.u_scale.value = particlesController.scale
					e.uniforms.u_particleSize.value = particlesController.size
					e.uniforms.u_bounce.value = particlesController.bounce
				})
			}


			function initGui() {
				let gui = new dat.GUI(),
					camerafolder = gui.addFolder('rotation'),
					particlesFolder = gui.addFolder('particles')

				camerafolder.open()
				camerafolder.add( effectController, "x", 0, 6, 0.0005).onChange( cameraValuesChanger );
				camerafolder.add( effectController, "y", 0, 6, 0.0005).onChange( cameraValuesChanger );
				camerafolder.add( effectController, "z", 0, 6, 0.0005).onChange( cameraValuesChanger );

				particlesFolder.open()
				particlesFolder.add( particlesController, "frequency", 0, 15, 0.0005).onChange( particlesValuesChanger );
				particlesFolder.add( particlesController, "speed", 0, 20, 0.0005).onChange( particlesValuesChanger );
				particlesFolder.add( particlesController, "displacement", 0, 6, 0.0005).onChange( particlesValuesChanger );
				particlesFolder.add( particlesController, "scale", 0, 10, 0.0005).onChange( particlesValuesChanger );
				particlesFolder.add( particlesController, "size", 0, 10, 0.001).onChange( particlesValuesChanger );
				particlesFolder.add( particlesController, "bounce", 0, 20, 0.001).onChange( particlesValuesChanger );

			}


			function onDocumentMouseMove( event ) {
				event.preventDefault();
				mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
				mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
			}


			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				requestAnimationFrame( animate );

				render();
				stats.update();

			}

			function render() {

				// particles.rotation.x += 0.002;
				// particles.rotation.y += 0.005;

				noise.seed(Math.random())


				var geometry = particles.geometry;
				var attributes = geometry.attributes;

				delta = clock.getElapsedTime()
				
				materials.forEach((e, i) => {
					e.uniforms.u_time.value = ((delta / deltaOffset) + (delta * (i % 40))) / 20
					// e.uniforms.noise.value = noise.perlin3(boxes[i].position.x, boxes[i].position.y, delta);
				})

				raycaster.setFromCamera( mouse, camera );

				intersects = raycaster.intersectObject( particles );

				if ( intersects.length > 0 ) {

					if ( INTERSECTED != intersects[ 0 ].index ) {

						// attributes.size.array[ INTERSECTED ] = PARTICLE_SIZE;

						INTERSECTED = intersects[ 0 ].index;

						// attributes.size.array[ INTERSECTED ] = PARTICLE_SIZE * 2;
						// attributes.size.needsUpdate = true;

					}

				} else if ( INTERSECTED !== null ) {

					// attributes.size.array[ INTERSECTED ] = PARTICLE_SIZE;
					attributes.size.needsUpdate = true;
					INTERSECTED = null;

				}

				renderer.render( scene, camera );

			}

		</script>

	</body>

</html>